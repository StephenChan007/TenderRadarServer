# 招投标监测微信小程序技术实现文档

## 一、系统概述

### 1.1 系统目标
构建一个自动化的招投标信息监测系统,实时抓取多个招投标网站的公告信息,通过关键字匹配筛选目标公告,并通过微信小程序订阅消息实时推送给用户。

### 1.2 核心功能
- 多站点招标公告自动采集
- 关键字智能匹配
- 公告智能去重(标题+内容)
- 微信小程序订阅消息推送
- 配置动态管理
- 高可用性保障

## 二、技术架构

### 2.1 整体架构
```
┌─────────────────────────────────────────────────┐
│                 微信小程序端                      │
│     (登录、订阅授权、配置管理、公告列表/详情)      │
└──────────────────┬──────────────────────────────┘
                   │ HTTPS API
┌──────────────────▼──────────────────────────────┐
│            微信云托管（Express.js）               │
│  ┌────────────────┐  ┌──────────────────────┐   │
│  │ API 服务        │  │ Worker（爬虫+匹配+推送）│   │
│  │ (配置/查询)     │  │ (队列消费/重试/幂等)     │   │
│  └────────────────┘  └──────────────────────┘   │
└──────────────────┬──────────────────────────────┘
                   │
┌──────────────────▼──────────────────────────────┐
│              数据存储（平台托管）                 │
│  ┌──────────────┐  ┌──────────────┐            │
│  │ MySQL（托管） │  │ Redis（托管） │            │
│  │(业务数据落库) │  │(锁/队列/缓存) │            │
│  └──────────────┘  └──────────────┘            │
└─────────────────────────────────────────────────┘
```

### 2.2 技术栈选型

**后端服务**
- Node.js (推荐) 或 Python
- 框架: Express/Koa (Node.js) 或 FastAPI (Python)
- 定时任务: node-cron 或 APScheduler

**爬虫引擎**
- Puppeteer/Playwright (动态网页)
- Cheerio (静态网页解析)
- Axios (HTTP请求)

**数据库**
- MySQL 8.0: 存储配置、用户、订阅关系、公告、去重归并、推送记录
- Redis: 去重缓存、分布式锁、任务队列/Stream、热点配置缓存

**小程序端**
- 微信小程序原生开发
- 云开发(可选,简化部署)

**部署**
- 微信云托管：运行 Express.js API 与 worker
- MySQL（托管）：存储配置、用户、公告、去重归并、推送记录
- Redis（托管）：分布式锁、队列/Stream、去重缓存、热点配置缓存

## 三、数据库设计

### 3.1 MySQL 表结构

> 说明：本方案采用 **MySQL + Redis**。公告内容与去重归并结果落库 MySQL，Redis 用于加速去重/锁/队列。

```sql
-- 用户表
CREATE TABLE `users` (
  `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
  `openid` VARCHAR(64) UNIQUE NOT NULL COMMENT '微信openid',
  `nickname` VARCHAR(100) COMMENT '昵称',
  `subscribe_status` TINYINT DEFAULT 1 COMMENT '订阅状态 1启用 0停用',
  `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  INDEX idx_openid (`openid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 监测站点配置表
CREATE TABLE `monitor_sites` (
  `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
  `site_name` VARCHAR(100) NOT NULL COMMENT '站点名称',
  `site_url` VARCHAR(500) NOT NULL COMMENT '站点URL',
  `list_page_url` VARCHAR(500) NOT NULL COMMENT '列表页URL',
  `crawler_type` VARCHAR(50) DEFAULT 'static' COMMENT '爬虫类型: static/dynamic',
  `selector_config` JSON COMMENT '选择器配置',
  `status` TINYINT DEFAULT 1 COMMENT '状态 1启用 0停用',
  `crawl_interval` INT DEFAULT 300 COMMENT '爬取间隔(秒)',
  `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 关键字配置表
CREATE TABLE `keywords` (
  `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
  `user_id` BIGINT NOT NULL COMMENT '用户ID',
  `keyword` VARCHAR(100) NOT NULL COMMENT '关键字',
  `match_type` VARCHAR(20) DEFAULT 'contain' COMMENT '匹配类型: contain/exact/regex',
  `priority` INT DEFAULT 0 COMMENT '优先级',
  `status` TINYINT DEFAULT 1 COMMENT '状态',
  `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (`user_id`) REFERENCES `users`(`id`) ON DELETE CASCADE,
  INDEX idx_user_keyword (`user_id`, `keyword`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 用户站点订阅关系表
CREATE TABLE `user_site_subscriptions` (
  `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
  `user_id` BIGINT NOT NULL,
  `site_id` BIGINT NOT NULL,
  `status` TINYINT DEFAULT 1,
  `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (`user_id`) REFERENCES `users`(`id`) ON DELETE CASCADE,
  FOREIGN KEY (`site_id`) REFERENCES `monitor_sites`(`id`) ON DELETE CASCADE,
  UNIQUE KEY uk_user_site (`user_id`, `site_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 公告表（含去重字段）
CREATE TABLE `notices` (
  `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
  `notice_uid` VARCHAR(64) NOT NULL COMMENT '公告唯一ID（建议: site_id + title_hash）',
  `site_id` BIGINT NOT NULL,
  `site_name` VARCHAR(100) NOT NULL,
  `title` VARCHAR(500) NOT NULL,
  `content` MEDIUMTEXT NOT NULL,
  `source_url` VARCHAR(1000) NOT NULL,
  `publish_time` DATETIME NULL,
  `crawl_time` DATETIME NOT NULL,

  `title_hash` CHAR(32) NOT NULL,
  `content_hash` CHAR(32) NOT NULL COMMENT '规范化内容hash（精确去重）',
  `simhash64` BIGINT UNSIGNED NOT NULL COMMENT '规范化内容simhash（近似去重）',
  `dedup_group_id` BIGINT NULL COMMENT '去重归并组ID',

  `status` VARCHAR(20) DEFAULT 'new' COMMENT 'new/pushed/expired',
  `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  UNIQUE KEY uk_notice_uid (`notice_uid`),
  INDEX idx_site_time (`site_id`, `publish_time`),
  INDEX idx_content_hash (`content_hash`),
  INDEX idx_simhash (`simhash64`),
  INDEX idx_dedup_group (`dedup_group_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 去重归并组表（记录“同一内容”集合）
CREATE TABLE `dedup_groups` (
  `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
  `content_hash` CHAR(32) NOT NULL,
  `simhash64` BIGINT UNSIGNED NOT NULL,
  `canonical_title` VARCHAR(500) NULL,
  `canonical_url` VARCHAR(1000) NULL,
  `first_notice_id` BIGINT NULL,
  `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE KEY uk_content_hash (`content_hash`),
  INDEX idx_simhash (`simhash64`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 推送记录表（幂等+可重试）
CREATE TABLE `push_records` (
  `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
  `user_id` BIGINT NOT NULL,
  `notice_id` BIGINT NOT NULL,
  `dedup_group_id` BIGINT NULL,
  `idempotency_key` VARCHAR(128) NOT NULL COMMENT '幂等键：user_id+dedup_group_id 或 user_id+notice_id',
  `push_status` TINYINT DEFAULT 0 COMMENT '0待推送 1成功 2失败',
  `push_time` DATETIME NULL,
  `retry_count` INT DEFAULT 0,
  `error_msg` TEXT NULL,
  `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  UNIQUE KEY uk_idempotency (`idempotency_key`),
  INDEX idx_user_notice (`user_id`, `notice_id`),
  INDEX idx_push_status (`push_status`, `created_at`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 3.2 Redis 数据结构

```
# 去重集合 (存储已处理的公告哈希)
SET notice:processed:hash:{content_hash} 1 EX 2592000  # 30天过期

# 爬虫任务队列
LIST crawler:queue:pending
LIST crawler:queue:processing

# 推送任务队列
LIST push:queue:pending

# 站点爬取锁 (防止重复爬取)
SET crawler:lock:site:{site_id} 1 EX 600  # 10分钟锁

# 爬取频率限制
SET crawler:rate:site:{site_id} 1 EX {interval}

# 用户推送频率控制
SET push:rate:user:{user_id} 1 EX 60  # 防止1分钟内重复推送
```

## 四、核心功能实现

### 4.1 爬虫模块

#### 4.1.1 爬虫调度器

```javascript
// crawler/scheduler.js
const cron = require('node-cron');
const redis = require('../utils/redis');
const { getAllActiveSites } = require('../models/site');
const CrawlerService = require('./crawlerService');

class CrawlerScheduler {
  constructor() {
    this.isRunning = false;
  }

  // 启动调度器
  start() {
    // 每5分钟执行一次
    cron.schedule('*/5 * * * *', async () => {
      await this.executeCrawlTasks();
    });
    
    console.log('爬虫调度器已启动');
  }

  async executeCrawlTasks() {
    if (this.isRunning) {
      console.log('上次任务未完成,跳过本次执行');
      return;
    }

    this.isRunning = true;
    try {
      const sites = await getAllActiveSites();
      
      for (const site of sites) {
        // 检查爬取间隔
        const canCrawl = await this.checkCrawlInterval(site);
        if (!canCrawl) continue;

        // 加锁防止并发
        const locked = await this.acquireLock(site.id);
        if (!locked) continue;

        try {
          await CrawlerService.crawlSite(site);
        } finally {
          await this.releaseLock(site.id);
        }
      }
    } finally {
      this.isRunning = false;
    }
  }

  async checkCrawlInterval(site) {
    const key = `crawler:rate:site:${site.id}`;
    const exists = await redis.exists(key);
    
    if (exists) return false;
    
    await redis.setex(key, site.crawl_interval, '1');
    return true;
  }

  async acquireLock(siteId) {
    const key = `crawler:lock:site:${siteId}`;
    const result = await redis.set(key, '1', 'EX', 600, 'NX');
    return result === 'OK';
  }

  async releaseLock(siteId) {
    const key = `crawler:lock:site:${siteId}`;
    await redis.del(key);
  }
}

module.exports = new CrawlerScheduler();
```

#### 4.1.2 爬虫服务

```javascript
// crawler/crawlerService.js
const axios = require('axios');
const cheerio = require('cheerio');
const puppeteer = require('puppeteer');
const crypto = require('crypto');
const NoticeService = require('../services/noticeService');

class CrawlerService {
  constructor() {
    this.browser = null;
  }

  async crawlSite(site) {
    console.log(`开始爬取站点: ${site.site_name}`);
    
    try {
      let notices = [];
      
      if (site.crawler_type === 'static') {
        notices = await this.crawlStaticSite(site);
      } else {
        notices = await this.crawlDynamicSite(site);
      }

      // 处理爬取的公告
      for (const notice of notices) {
        await NoticeService.processNotice(notice, site);
      }

      console.log(`站点 ${site.site_name} 爬取完成,获取 ${notices.length} 条公告`);
    } catch (error) {
      console.error(`站点 ${site.site_name} 爬取失败:`, error);
    }
  }

  // 静态网页爬取
  async crawlStaticSite(site) {
    const response = await axios.get(site.list_page_url, {
      timeout: 30000,
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      }
    });

    const $ = cheerio.load(response.data);
    const config = JSON.parse(site.selector_config);
    const notices = [];

    $(config.listSelector).each((index, element) => {
      try {
        const title = $(element).find(config.titleSelector).text().trim();
        const link = $(element).find(config.linkSelector).attr('href');
        const dateStr = $(element).find(config.dateSelector).text().trim();

        if (title && link) {
          notices.push({
            title,
            source_url: this.normalizeUrl(link, site.site_url),
            publish_date: this.parseDate(dateStr),
            site_id: site.id,
            site_name: site.site_name
          });
        }
      } catch (error) {
        console.error('解析列表项失败:', error);
      }
    });

    return notices;
  }

  // 动态网页爬取 (需要JavaScript渲染)
  async crawlDynamicSite(site) {
    if (!this.browser) {
      this.browser = await puppeteer.launch({
        headless: true,
        args: ['--no-sandbox', '--disable-setuid-sandbox']
      });
    }

    const page = await this.browser.newPage();
    await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36');
    
    try {
      await page.goto(site.list_page_url, {
        waitUntil: 'networkidle2',
        timeout: 30000
      });

      const config = JSON.parse(site.selector_config);
      
      const notices = await page.evaluate((config, siteId, siteName) => {
        const results = [];
        const elements = document.querySelectorAll(config.listSelector);
        
        elements.forEach(el => {
          const titleEl = el.querySelector(config.titleSelector);
          const linkEl = el.querySelector(config.linkSelector);
          const dateEl = el.querySelector(config.dateSelector);
          
          if (titleEl && linkEl) {
            results.push({
              title: titleEl.textContent.trim(),
              source_url: linkEl.href,
              publish_date: dateEl ? dateEl.textContent.trim() : '',
              site_id: siteId,
              site_name: siteName
            });
          }
        });
        
        return results;
      }, config, site.id, site.site_name);

      return notices;
    } finally {
      await page.close();
    }
  }

  // 获取公告详情
  async fetchNoticeDetail(url, crawlerType = 'static') {
    if (crawlerType === 'static') {
      const response = await axios.get(url, { timeout: 30000 });
      const $ = cheerio.load(response.data);
      
      // 提取正文内容 (需根据实际网站结构调整)
      const content = $('.content, .article-content, #content').text().trim();
      return content;
    } else {
      // 动态页面获取详情
      const page = await this.browser.newPage();
      try {
        await page.goto(url, { waitUntil: 'networkidle2', timeout: 30000 });
        const content = await page.evaluate(() => {
          const contentEl = document.querySelector('.content, .article-content, #content');
          return contentEl ? contentEl.textContent.trim() : '';
        });
        return content;
      } finally {
        await page.close();
      }
    }
  }

  normalizeUrl(url, baseUrl) {
    if (url.startsWith('http')) return url;
    if (url.startsWith('//')) return 'https:' + url;
    if (url.startsWith('/')) return new URL(baseUrl).origin + url;
    return baseUrl + '/' + url;
  }

  parseDate(dateStr) {
    // 根据实际日期格式解析
    // 例: "2025-01-12" 或 "2025/01/12" 或 "01-12"
    if (!dateStr) return new Date();
    
    const patterns = [
      /(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})/,  // 2025-01-12
      /(\d{1,2})[-\/](\d{1,2})/                // 01-12
    ];

    for (const pattern of patterns) {
      const match = dateStr.match(pattern);
      if (match) {
        if (match[1].length === 4) {
          return new Date(`${match[1]}-${match[2]}-${match[3]}`);
        } else {
          const year = new Date().getFullYear();
          return new Date(`${year}-${match[1]}-${match[2]}`);
        }
      }
    }

    return new Date();
  }
}

module.exports = new CrawlerService();
```

### 4.2 公告处理与去重

```javascript
// services/noticeService.js
const crypto = require('crypto');
const redis = require('../utils/redis');
const Notice = require('../models/notice');
const KeywordService = require('./keywordService');
const PushService = require('./pushService');

class NoticeService {
  async processNotice(noticeData, site) {
    // 1. 生成唯一标识
    const titleHash = this.generateHash(noticeData.title);
    const noticeId = `${site.id}_${titleHash}`;

    // 2. 检查标题去重
    if (await this.isDuplicate(noticeId)) {
      console.log(`公告已存在(标题重复): ${noticeData.title}`);
      return;
    }

    // 3. 获取详细内容
    let content = '';
    try {
      content = await require('../crawler/crawlerService').fetchNoticeDetail(
        noticeData.source_url,
        site.crawler_type
      );
    } catch (error) {
      console.error('获取详情失败:', error);
      content = noticeData.title; // 降级使用标题
    }

    // 4. 内容去重
    const contentHash = this.generateHash(content);
    if (await this.isContentDuplicate(contentHash)) {
      console.log(`公告已存在(内容重复): ${noticeData.title}`);
      return;
    }

    // 5. 关键字匹配
    const matchedKeywords = await KeywordService.matchKeywords(
      noticeData.title,
      content
    );

    if (matchedKeywords.length === 0) {
      console.log(`公告无匹配关键字: ${noticeData.title}`);
      return;
    }

    // 6. 保存公告
    const notice = await Notice.create({
      notice_id: noticeId,
      site_id: site.id,
      site_name: site.site_name,
      title: noticeData.title,
      content: content,
      content_hash: contentHash,
      title_hash: titleHash,
      publish_date: noticeData.publish_date,
      source_url: noticeData.source_url,
      keywords_matched: matchedKeywords.map(k => k.keyword),
      status: 'new'
    });

    // 7. 标记为已处理
    await this.markAsProcessed(noticeId, contentHash);

    // 8. 触发推送
    await PushService.pushToUsers(notice, matchedKeywords);

    console.log(`新公告已处理: ${noticeData.title}`);
  }

  generateHash(text) {
    return crypto.createHash('md5').update(text).digest('hex');
  }

  async isDuplicate(noticeId) {
    const key = `notice:processed:id:${noticeId}`;
    return await redis.exists(key) === 1;
  }

  async isContentDuplicate(contentHash) {
    const key = `notice:processed:hash:${contentHash}`;
    return await redis.exists(key) === 1;
  }

  async markAsProcessed(noticeId, contentHash) {
    const ttl = 30 * 24 * 60 * 60; // 30天
    await redis.setex(`notice:processed:id:${noticeId}`, ttl, '1');
    await redis.setex(`notice:processed:hash:${contentHash}`, ttl, '1');
  }
}

module.exports = new NoticeService();
```

### 4.3 关键字匹配

```javascript
// services/keywordService.js
const Keyword = require('../models/keyword');

class KeywordService {
  async matchKeywords(title, content) {
    const allKeywords = await Keyword.findAll({ where: { status: 1 } });
    const matchedKeywords = [];
    const text = (title + ' ' + content).toLowerCase();

    for (const kw of allKeywords) {
      let isMatch = false;
      const keyword = kw.keyword.toLowerCase();

      switch (kw.match_type) {
        case 'exact':
          // 精确匹配(带边界)
          const regex = new RegExp(`\\b${this.escapeRegex(keyword)}\\b`, 'i');
          isMatch = regex.test(text);
          break;
        
        case 'regex':
          // 正则匹配
          try {
            const customRegex = new RegExp(kw.keyword, 'i');
            isMatch = customRegex.test(text);
          } catch (error) {
            console.error('正则表达式错误:', error);
          }
          break;
        
        case 'contain':
        default:
          // 包含匹配
          isMatch = text.includes(keyword);
      }

      if (isMatch) {
        matchedKeywords.push(kw);
      }
    }

    // 按优先级排序
    return matchedKeywords.sort((a, b) => b.priority - a.priority);
  }

  escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }
}

module.exports = new KeywordService();
```

### 4.4 微信小程序订阅消息推送（推荐）

> 说明：本系统采用**小程序订阅消息**进行实时逐条推送。用户在小程序端对模板进行授权（`wx.requestSubscribeMessage`），后端在命中公告后调用订阅消息发送接口。
>
> 关键点：
> 1) **逐条推送**：每条命中公告独立推送；
> 2) **幂等**：对同一用户+同一去重归并组（dedup_group）只推送一次，防止重复；
> 3) **队列化**：推送任务进入 Redis 队列/Stream，由 worker 异步消费并重试。

```javascript
// services/pushService.js (示意)
const axios = require('axios');
const Redis = require('../utils/redis');
const db = require('../utils/mysql');

class PushService {
  constructor() {
    this.accessToken = null;
    this.tokenExpireTime = 0;
  }

  // 由 NoticeService 调用：写入推送队列（不要在爬虫线程里同步发消息）
  async enqueuePushJobs({ noticeId, dedupGroupId, userIds }) {
    for (const userId of userIds) {
      const idempotencyKey = `${userId}:${dedupGroupId || noticeId}`;
      // 先落库/占位，利用 uk_idempotency 保证幂等
      const inserted = await this.tryCreatePushRecord({ userId, noticeId, dedupGroupId, idempotencyKey });
      if (!inserted) continue;
      await Redis.lpush('push:queue:pending', JSON.stringify({ userId, noticeId, dedupGroupId, idempotencyKey }));
    }
  }

  // Worker 消费：真正发送订阅消息
  async consumeAndSend(job) {
    const { userId, noticeId, idempotencyKey } = job;

    const user = await db.getUserById(userId);
    if (!user?.openid) return;

    const notice = await db.getNoticeById(noticeId);
    if (!notice) return;

    const accessToken = await this.getAccessToken();
    const result = await this.sendSubscribeMessage(accessToken, user.openid, notice);

    await db.updatePushRecordByIdempotencyKey(idempotencyKey, result.success, result.error);
  }

  async getAccessToken() {
    const now = Date.now();
    if (this.accessToken && now < this.tokenExpireTime) return this.accessToken;

    const appId = process.env.WECHAT_APPID;
    const appSecret = process.env.WECHAT_APPSECRET;
    const url = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${appId}&secret=${appSecret}`;

    const resp = await axios.get(url);
    if (!resp.data.access_token) throw new Error('获取access_token失败: ' + JSON.stringify(resp.data));

    this.accessToken = resp.data.access_token;
    this.tokenExpireTime = now + (resp.data.expires_in - 300) * 1000;
    return this.accessToken;
  }

  async sendSubscribeMessage(accessToken, openid, notice) {
    // 订阅消息发送接口（小程序）
    const url = `https://api.weixin.qq.com/cgi-bin/message/subscribe/send?access_token=${accessToken}`;

    // 注意：template_id、page、data 字段需要按你在小程序后台配置的模板来填写
    const payload = {
      touser: openid,
      template_id: process.env.WECHAT_SUBSCRIBE_TEMPLATE_ID,
      page: `pages/detail/detail?id=${notice.id}`,
      data: {
        // 示例字段名仅演示：以你后台模板的 keyword1/thing1/date2 等为准
        thing1: { value: notice.title.slice(0, 20) },
        thing2: { value: notice.site_name.slice(0, 20) },
        date3: { value: new Date(notice.publish_time || notice.crawl_time).toISOString().slice(0, 10) },
      }
    };

    try {
      const resp = await axios.post(url, payload);
      if (resp.data.errcode === 0) return { success: true };
      return { success: false, error: `errcode=${resp.data.errcode}, errmsg=${resp.data.errmsg}` };
    } catch (e) {
      return { success: false, error: e.message };
    }
  }

  async tryCreatePushRecord({ userId, noticeId, dedupGroupId, idempotencyKey }) {
    // 伪代码：插入 push_records，若 uk_idempotency 冲突则返回 false
    return db.insertPushRecordIgnoreDup({ userId, noticeId, dedupGroupId, idempotencyKey });
  }
}

module.exports = new PushService();
```

## 五、小程序端实现

### 5.1 页面结构

```
pages/
├── index/          # 首页 - 公告列表
│   ├── index.wxml
│   ├── index.js
│   └── index.wxss
├── config/         # 配置管理
│   ├── sites/      # 站点配置
│   ├── keywords/   # 关键字配置
│   └── subscription/ # 订阅管理
├── detail/         # 公告详情
└── mine/           # 个人中心
```

### 5.2 关键页面代码示例

> 说明：本项目后端部署在 **微信云托管（Express.js）**，小程序端通过 `wx.request` 调用后端 API（不使用 `wx.cloud.callFunction`）。

#### 订阅消息授权（建议在“开启监测/保存配置”时引导一次）

```javascript
// 示例：用户点击“开启推送”按钮
async function requestSubscribe() {
  const tmplIds = [
    'YOUR_TEMPLATE_ID_1',
  ];

  return new Promise((resolve, reject) => {
    wx.requestSubscribeMessage({
      tmplIds,
      success: resolve,
      fail: reject,
    });
  });
}
```

#### 首页 - 公告列表（调用云托管 API）

```javascript
// pages/index/index.js
const API_BASE = 'https://YOUR_CLOUD_HOST_DOMAIN';

Page({
  data: {
    notices: [],
    loading: false,
    page: 1,
    hasMore: true
  },

  onLoad() {
    this.loadNotices();
  },

  async loadNotices() {
    if (this.data.loading || !this.data.hasMore) return;
    this.setData({ loading: true });

    try {
      const res = await new Promise((resolve, reject) => {
        wx.request({
          url: `${API_BASE}/api/notices`,
          method: 'GET',
          data: { page: this.data.page, pageSize: 20 },
          success: resolve,
          fail: reject,
        });
      });

      const newNotices = res.data?.data || [];
      this.setData({
        notices: [...this.data.notices, ...newNotices],
        hasMore: newNotices.length === 20,
        page: this.data.page + 1,
        loading: false
      });
    } catch (error) {
      console.error('加载公告失败', error);
      wx.showToast({ title: '加载失败', icon: 'none' });
      this.setData({ loading: false });
    }
  },

  onReachBottom() {
    this.loadNotices();
  },

  viewDetail(e) {
    const noticeId = e.currentTarget.dataset.id;
    wx.navigateTo({
      url: `/pages/detail/detail?id=${noticeId}`
    });
  }
});
```

#### 关键字配置（调用云托管 API）

```javascript
// pages/config/keywords/keywords.js
const API_BASE = 'https://YOUR_CLOUD_HOST_DOMAIN';

Page({
  data: {
    keywords: [],
    inputKeyword: '',
    matchType: 'contain'
  },

  onLoad() {
    this.loadKeywords();
  },

  async loadKeywords() {
    try {
      const res = await new Promise((resolve, reject) => {
        wx.request({
          url: `${API_BASE}/api/keywords`,
          method: 'GET',
          success: resolve,
          fail: reject,
        });
      });
      this.setData({ keywords: res.data?.data || [] });
    } catch (error) {
      wx.showToast({ title: '加载失败', icon: 'none' });
    }
  },

  async addKeyword() {
    const { inputKeyword, matchType } = this.data;
    if (!inputKeyword.trim()) {
      wx.showToast({ title: '请输入关键字', icon: 'none' });
      return;
    }

    try {
      await new Promise((resolve, reject) => {
        wx.request({
          url: `${API_BASE}/api/keywords`,
          method: 'POST',
          data: { keyword: inputKeyword, matchType },
          success: resolve,
          fail: reject,
        });
      });

      wx.showToast({ title: '添加成功', icon: 'success' });
      this.setData({ inputKeyword: '' });
      this.loadKeywords();
    } catch (error) {
      wx.showToast({ title: '添加失败', icon: 'none' });
    }
  },

  async deleteKeyword(e) {
    const id = e.currentTarget.dataset.id;

    wx.showModal({
      title: '确认删除',
      content: '确定要删除这个关键字吗?',
      success: async (res) => {
        if (!res.confirm) return;

        try {
          await new Promise((resolve, reject) => {
            wx.request({
              url: `${API_BASE}/api/keywords/${id}`,
              method: 'DELETE',
              success: resolve,
              fail: reject,
            });
          });

          wx.showToast({ title: '删除成功', icon: 'success' });
          this.loadKeywords();
        } catch (error) {
          wx.showToast({ title: '删除失败', icon: 'none' });
        }
      }
    });
  }
});
```

## 六、系统稳定性保障

### 6.1 高可用设计

**1. 服务监控与自动重启**

```javascript
// monitor/healthCheck.js
const cron = require('node-cron');
const axios = require('axios');
const { exec } = require('child_process');

class HealthMonitor {
  start() {
    // 每分钟检查服务健康状态
    cron.schedule('* * * * *', async () => {
      await this.checkServices();
    });
  }

  async checkServices() {
    const services = [
      { name: 'API服务', url: 'http://localhost:3000/health' },
      { name: 'Redis（托管）', check: () => this.checkRedis() },
      { name: 'MySQL（托管）', check: () => this.checkMySQL() }
    ];

    for (const service of services) {
      try {
        if (service.url) {
          await axios.get(service.url, { timeout: 5000 });
        } else if (service.check) {
          await service.check();
        }
        console.log(`✓ ${service.name} 正常`);
      } catch (error) {
        console.error(`✗ ${service.name} 异常:`, error.message);
        await this.alertAdmin(service.name, error.message);
        
        if (service.name === 'API服务') {
          await this.restartService();
        }
      }
    }
  }

  async checkRedis() {
    const redis = require('../utils/redis');
    await redis.ping();
  }

  async checkMySQL() {
    const db = require('../utils/database');
    await db.query('SELECT 1');
  }


  async alertAdmin(serviceName, errorMsg) {
    // 发送告警(邮件、短信、企业微信等)
    console.log(`[告警] ${serviceName} 服务异常: ${errorMsg}`);
    
    // 示例: 发送企业微信告警
    try {
      await axios.post(process.env.ALERT_WEBHOOK_URL, {
        msgtype: 'text',
        text: {
          content: `【系统告警】\n服务: ${serviceName}\n错误: ${errorMsg}\n时间: ${new Date().toLocaleString()}`
        }
      });
    } catch (err) {
      console.error('发送告警失败:', err);
    }
  }

  async restartService() {
    // 微信云托管内服务的拉起/重启由平台负责；这里更建议做“告警 + 自动降载/熔断”。
    console.log('检测到 API 异常，已触发告警（云托管由平台负责重启/拉起）');
  }
}

module.exports = new HealthMonitor();
```

> 说明：在 **微信云托管** 场景下，无需自行维护 PM2/守护进程配置。应重点关注：健康检查、日志、告警、队列重试、幂等与限流。

### 6.2 错误处理与重试机制

```javascript
// utils/retry.js
async function retryWithBackoff(fn, maxRetries = 3, initialDelay = 1000) {
  let lastError;
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      
      if (i < maxRetries - 1) {
        const delay = initialDelay * Math.pow(2, i);
        console.log(`第 ${i + 1} 次失败,等待 ${delay}ms 后重试...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  throw lastError;
}

module.exports = { retryWithBackoff };
```

### 6.3 日志系统

```javascript
// utils/logger.js
const winston = require('winston');
const DailyRotateFile = require('winston-daily-rotate-file');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new DailyRotateFile({
      filename: 'logs/application-%DATE%.log',
      datePattern: 'YYYY-MM-DD',
      maxSize: '20m',
      maxFiles: '30d'
    }),
    new DailyRotateFile({
      filename: 'logs/error-%DATE%.log',
      datePattern: 'YYYY-MM-DD',
      level: 'error',
      maxSize: '20m',
      maxFiles: '30d'
    })
  ]
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}

module.exports = logger;
```

### 6.4 数据库连接池

```javascript
// utils/database.js
const mysql = require('mysql2/promise');

const pool = mysql.createPool({
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0,
  enableKeepAlive: true,
  keepAliveInitialDelay: 0
});

// 连接检测
pool.on('connection', (connection) => {
  console.log('新建数据库连接');
});

pool.on('error', (err) => {
  console.error('数据库连接池错误:', err);
});

module.exports = pool;
```

## 七、部署方案（微信云托管 + 托管 MySQL/Redis）

### 7.1 部署形态

- **微信云托管**：运行 API 服务（Express.js）与 Worker（爬虫/匹配/推送消费）。
- **MySQL（托管）**：存储用户、站点配置、关键词、公告、去重归并、推送记录。
- **Redis（托管）**：分布式锁、队列/Stream、去重缓存、热点配置缓存。

> 说明：本方案不再使用 Docker Compose/PM2/MongoDB 的自建部署方式。

### 7.2 环境变量配置（示例）

```bash
# 运行环境
NODE_ENV=production
PORT=3000

# MySQL（托管）
DB_HOST=your_mysql_host
DB_PORT=3306
DB_USER=your_user
DB_PASSWORD=your_password
DB_NAME=bid_monitor

# Redis（托管）
REDIS_HOST=your_redis_host
REDIS_PORT=6379
REDIS_PASSWORD=your_password

# 微信小程序（订阅消息）
WECHAT_APPID=your_appid
WECHAT_APPSECRET=your_appsecret
WECHAT_SUBSCRIBE_TEMPLATE_ID=your_subscribe_template_id

# 告警（可选：企业微信群机器人 Webhook）
ALERT_WEBHOOK_URL=https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=xxx
```

### 7.3 部署要点（落地清单）

1. 在微信云托管创建服务，选择 **Express.js** 运行环境。
2. 配置云托管环境变量（上面的 MySQL/Redis/小程序参数）。
3. 初始化 MySQL 表结构（执行本文第 3 章 SQL）。
4. 在云托管中同时部署：
   - API：提供小程序端配置管理/公告查询接口；
   - Worker：定时抓取、匹配、入库、写入推送队列，并异步发送订阅消息。
5. 观测与运维：关注云托管日志、队列堆积、推送失败率与站点爬取失败率。

## 八、性能优化建议

### 8.1 爬虫优化

1. **并发控制**: 使用Promise池限制并发数,避免触发反爬
```javascript
const pLimit = require('p-limit');
const limit = pLimit(3); // 最多3个并发

const tasks = sites.map(site => 
  limit(() => crawlSite(site))
);
await Promise.all(tasks);
```

2. **请求缓存**: 对相同URL的请求结果缓存
3. **User-Agent轮换**: 避免被识别为机器人
4. **代理池**: 必要时使用代理IP池

### 8.2 数据库优化

1. **索引优化**: 为常用查询字段建立索引
2. **分页查询**: 避免一次性加载大量数据
3. **定期清理**: 删除过期数据(如30天前的公告)

```sql
-- 定期清理过期数据（示例：保留最近 30 天）
-- 可在云托管 Worker 中用定时任务执行，或使用数据库事件/运维作业执行。
DELETE FROM notices
WHERE crawl_time < (NOW() - INTERVAL 30 DAY);
```

> 注意：如果你需要“保留去重归并组与推送记录的一致性”，可以先标记 notices.status='expired'，再分批物理删除；同时按需清理 dedup_groups / push_records 的历史数据。

### 8.3 缓存策略

1. **热点数据缓存**: 将高频访问的配置数据缓存到Redis
2. **查询结果缓存**: 缓存公告列表查询结果(5分钟)
3. **CDN加速**: 静态资源使用CDN

## 九、安全措施

### 9.1 接口安全

```javascript
// middleware/auth.js
const jwt = require('jsonwebtoken');

function authMiddleware(req, res, next) {
  const token = req.headers.authorization?.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ error: '未授权' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.userId = decoded.userId;
    next();
  } catch (error) {
    res.status(401).json({ error: '无效token' });
  }
}
```

### 9.2 防爬虫措施

1. **请求频率限制**
```javascript
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 100 // 最多100个请求
});

app.use('/api/', limiter);
```

2. **IP黑名单**: 异常IP自动加入黑名单
3. **验证码**: 敏感操作添加验证码

### 9.3 数据安全

1. **敏感信息加密**: 用户手机号等敏感信息加密存储
2. **SQL注入防护**: 使用参数化查询
3. **XSS防护**: 输出内容进行HTML转义
4. **定期备份**: 每天自动备份数据库

```bash
# 数据库备份脚本
#!/bin/bash
DATE=$(date +%Y%m%d_%H%M%S)
mysqldump -u root -p${DB_PASSWORD} bid_monitor > backup_${DATE}.sql
# 保留最近7天的备份
find ./backups -name "backup_*.sql" -mtime +7 -delete
```

## 十、监控与运维

### 10.1 关键指标监控

1. **爬虫成功率**: 每个站点的爬取成功率
2. **推送成功率**: 消息推送成功率
3. **响应时间**: API接口响应时间
4. **错误率**: 系统错误发生频率
5. **资源使用**: CPU、内存、磁盘使用率

### 10.2 告警规则

```javascript
// monitor/alertRules.js
const rules = [
  {
    name: '爬虫失败率过高',
    check: async () => {
      const failRate = await getCrawlFailRate();
      return failRate > 0.3; // 失败率>30%
    },
    alert: '过去1小时爬虫失败率超过30%'
  },
  {
    name: '推送失败率过高',
    check: async () => {
      const failRate = await getPushFailRate();
      return failRate > 0.2;
    },
    alert: '过去1小时推送失败率超过20%'
  },
  {
    name: '内存使用过高',
    check: () => {
      const usage = process.memoryUsage();
      return usage.heapUsed / usage.heapTotal > 0.9;
    },
    alert: '系统内存使用超过90%'
  }
];
```

## 十一、扩展性考虑

### 11.1 水平扩展

1. **多实例部署**: 使用Nginx负载均衡
2. **消息队列**: 使用RabbitMQ或Kafka处理推送任务
3. **数据库分库分表**: 数据量大时考虑分库分表

### 11.2 功能扩展

1. **智能推荐**: 基于历史行为推荐相关公告
2. **数据分析**: 统计分析招标趋势
3. **多渠道推送**: 支持邮件、短信、钉钉等
4. **AI摘要**: 使用AI生成公告摘要

## 十二、成本估算

### 12.1 服务器配置建议

**小规模(100用户以内)**
- CPU: 2核
- 内存: 4GB
- 带宽: 3Mbps
- 存储: 50GB SSD
- 月成本: 约200-300元

**中等规模(1000用户)**
- CPU: 4核
- 内存: 8GB
- 带宽: 5Mbps
- 存储: 100GB SSD
- 月成本: 约500-800元

### 12.2 其他成本

- 微信认证费: 300元/年
- 域名: 50-100元/年
- SSL证书: 免费(Let's Encrypt)或付费
- 云数据库: 可选,按需购买

## 十三、开发时间估算

- 需求分析与设计: 2-3天
- 后端开发(爬虫+API): 7-10天
- 小程序开发: 5-7天
- 测试与调试: 3-5天
- 部署上线: 1-2天

**总计**: 约3-4周(单人开发)

## 十四、注意事项与风险

### 14.1 法律合规

1. **网站爬取政策**: 遵守目标网站的robots.txt协议
2. **数据使用**: 仅用于个人或企业内部,不公开传播
3. **版权问题**: 注明信息来源,不做商业用途

### 14.2 技术风险

1. **网站结构变化**: 目标网站改版导致爬虫失效
   - 解决: 建立监控机制,及时调整选择器
2. **反爬虫策略**: 被目标网站封禁IP
   - 解决: 降低爬取频率,使用代理
3. **数据准确性**: 去重算法可能误判
   - 解决: 人工审核+反馈机制

### 14.3 运营建议

1. **逐步上线**: 先支持1-2个站点,稳定后逐步扩展
2. **用户反馈**: 建立反馈渠道,持续优化
3. **定期维护**: 每周检查爬虫状态,更新配置
4. **数据质量**: 定期抽查推送内容的准确性

---

## 附录A: 常见招投标网站API

以下是一些常见招投标网站的示例配置:

```json
{
  "sites": [
    {
      "site_name": "中国政府采购网",
      "site_url": "http://www.ccgp.gov.cn",
      "list_page_url": "http://www.ccgp.gov.cn/cggg/dfgg/",
      "crawler_type": "static",
      "selector_config": {
        "listSelector": ".vT_detail_llist > ul > li",
        "titleSelector": "a",
        "linkSelector": "a",
        "dateSelector": "span"
      }
    },
    {
      "site_name": "全国公共资源交易平台",
      "site_url": "http://deal.ggzy.gov.cn",
      "list_page_url": "http://deal.ggzy.gov.cn/ds/deal/dealList.html",
      "crawler_type": "dynamic",
      "selector_config": {
        "listSelector": ".ewb-list-node",
        "titleSelector": ".ewb-list-node-title a",
        "linkSelector": ".ewb-list-node-title a",
        "dateSelector": ".ewb-list-node-time"
      }
    }
  ]
}
```

## 附录B: 小程序订阅消息模板字段示例

> 说明：小程序订阅消息模板的字段名以小程序后台模板为准（常见为 `thing1`、`thing2`、`date3` 等）。后端调用订阅消息接口时，需要按模板字段名组装 `data`。

示例（与本文 4.4 `sendSubscribeMessage` 章节一致）：

```json
{
  "touser": "OPENID",
  "template_id": "WECHAT_SUBSCRIBE_TEMPLATE_ID",
  "page": "pages/detail/detail?id=NOTICE_ID",
  "data": {
    "thing1": { "value": "公告标题（截断）" },
    "thing2": { "value": "公告来源/站点" },
    "date3": { "value": "2026-01-13" }
  }
}
```

> 提醒：订阅消息需要用户在小程序端通过 `wx.requestSubscribeMessage` 授权；且一次授权通常对应一次或有限次数的发送额度，具体规则以微信侧最新策略为准。

---

**文档版本**: v1.0
**最后更新**: 2025-01-12
**维护者**: [您的名字]